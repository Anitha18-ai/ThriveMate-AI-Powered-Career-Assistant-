import os
import requests
import logging
from typing import Dict, Any, Optional
import config

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def get_career_advice(message: str) -> str:
    """
    Get career advice from Hugging Face API using DialoGPT model
    
    Args:
        message: User message/question to process
        
    Returns:
        Response from the AI assistant
    """
    logger.debug(f"Getting career advice for message: {message}")
    
    # Get API key from environment variables
    api_key = os.environ.get('HUGGINGFACE_API_KEY', config.HUGGINGFACE_API_KEY)
    
    if not api_key:
        logger.error("Hugging Face API key not found")
        return "I'm sorry, I can't provide advice at the moment due to a configuration issue. Please try again later."
    
    # Prepare request
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    # Add career context to the message to make the model respond as a career advisor
    context = "You are a career coach and job search expert. Provide helpful, professional advice for this career question: "
    formatted_message = context + message
    
    # API request payload
    payload = {
        "inputs": formatted_message,
        "options": {
            "wait_for_model": True,
            "use_cache": True
        }
    }
    
    try:
        # Make request to Hugging Face API
        response = requests.post(
            config.HUGGINGFACE_API_URL,
            headers=headers,
            json=payload
        )
        
        # Check if request was successful
        response.raise_for_status()
        
        # Parse response
        result = response.json()
        
        # Extract the generated text from the response
        if isinstance(result, list) and len(result) > 0:
            generated_text = result[0].get('generated_text', '')
            
            # Clean up the response
            clean_response = clean_ai_response(generated_text, message)
            
            return clean_response
        else:
            logger.error(f"Unexpected response format: {result}")
            return "I'm sorry, I couldn't generate a helpful response. Please try asking in a different way."
            
    except requests.exceptions.RequestException as e:
        logger.exception(f"Error getting career advice: {str(e)}")
        return "I'm sorry, there was an error connecting to the advice service. Please try again later."

def clean_ai_response(generated_text: str, original_message: str) -> str:
    """
    Clean up the AI-generated response
    
    Args:
        generated_text: Raw text generated by the model
        original_message: The original user message
        
    Returns:
        Cleaned response
    """
    # Remove the original message if it's included in the response
    if generated_text.startswith(original_message):
        generated_text = generated_text[len(original_message):].strip()
    
    # Sometimes the model includes its own prompt text, so try to remove that
    context_prefixes = [
        "You are a career coach and job search expert.",
        "As a career coach and job search expert,",
        "I am a career coach and job search expert."
    ]
    
    for prefix in context_prefixes:
        if generated_text.startswith(prefix):
            generated_text = generated_text[len(prefix):].strip()
    
    # Remove any leading colons or dashes that might be part of the formatting
    generated_text = generated_text.lstrip(':- ')
    
    # If the response is empty after cleaning, return a fallback message
    if not generated_text:
        return "I understand your question about career development. To provide more specific advice, could you please provide more details about your situation?"
    
    # Ensure the response starts with a capital letter
    if generated_text and len(generated_text) > 0:
        generated_text = generated_text[0].upper() + generated_text[1:]
    
    return generated_text

def get_similar_questions(query: str) -> list:
    """
    Get similar career-related questions to the user's query
    
    Args:
        query: User's question
        
    Returns:
        List of similar questions
    """
    common_questions = [
        "How do I write a compelling resume?",
        "What should I include in my cover letter?",
        "How do I prepare for a job interview?",
        "How do I negotiate a higher salary?",
        "How can I improve my LinkedIn profile?",
        "How do I address employment gaps in my resume?",
        "What are some common interview questions and how should I answer them?",
        "How do I make a career change to a different industry?",
        "What skills are most in-demand in today's job market?",
        "How do I network effectively for job opportunities?"
    ]
    
    # For a simple implementation, return some fixed common questions
    # In a more advanced version, this could use text similarity to find relevant questions
    return common_questions[:3]
